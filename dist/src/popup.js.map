{
  "version": 3,
  "sources": ["../../build/util.js", "../../build/storage.js", "../../build/popup.js"],
  "sourcesContent": ["// util.ts provides utility functions that can be reused in other modules\r\nexport function addMinutes(date, minutes) {\r\n    return new Date(date.getTime() + minutes * 60000);\r\n}\r\nexport function cleanDomain(urls) {\r\n    // check to see if urls exist\r\n    if (urls[0] === undefined) {\r\n        // return empty if not\r\n        return '';\r\n    }\r\n    else {\r\n        // regex match for url\r\n        const activeURL = urls[0].match(/^[\\w]+:\\/{2}([\\w\\.:-]+)/);\r\n        // no matching sites, return empty\r\n        if (activeURL == null) {\r\n            return '';\r\n        }\r\n        else {\r\n            // strip www.\r\n            return activeURL[1].replace('www.', '');\r\n        }\r\n    }\r\n}\r\nexport function insertAfter(newNode, existingNode) {\r\n    existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);\r\n}\r\nexport function createDivFromHTML(htmlString) {\r\n    const newDiv = document.createElement('div');\r\n    newDiv.insertAdjacentHTML('beforeend', htmlString);\r\n    return newDiv;\r\n}\r\nexport function getElementFromForm(id) {\r\n    return document.getElementById(id);\r\n}\r\n", "// storage.ts provides a thin wrapper around the chrome storage api to make it easier to read/write from it\r\n// you can also find helper functions that read/write to chrome storage\r\nimport { addMinutes } from './util';\r\n// helper function to retrive chrome storage object\r\n// usage:\r\n//\r\n// getStorage(null).then(storage => {\r\n//     ...\r\n// })\r\nexport function getStorage() {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.get(null, (storage) => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve(storage);\r\n            }\r\n        });\r\n    });\r\n}\r\n// helper function to set fields in chrome storage\r\n// usage:\r\n//\r\n// getStorage({enableBlobs: false}).then(storage => {\r\n//     ...\r\n// })\r\nexport function setStorage(key) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.set(key, () => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n// Add a single url to blocklist (does nothing if url is already in list)\r\nexport function addToBlocked(url, callback) {\r\n    getStorage().then((storage) => {\r\n        if (!storage.blockedSites.includes(url)) {\r\n            storage.blockedSites.push(url);\r\n            setStorage({ blockedSites: storage.blockedSites }).then(() => {\r\n                console.log(`${url} added to blocked sites`);\r\n                callback ? callback() : () => { };\r\n            });\r\n        }\r\n    });\r\n}\r\n// Remove single url from blocklist (does nothing if url is not in list)\r\nexport function removeFromBlocked(url) {\r\n    getStorage().then((storage) => {\r\n        let blockedSites = storage.blockedSites;\r\n        blockedSites = blockedSites.filter((e) => e !== url);\r\n        setStorage({ blockedSites: blockedSites }).then(() => {\r\n            console.log(`removed ${url} from blocked sites`);\r\n        });\r\n    });\r\n}\r\n// Add a single url to whitelist with associated whitelist duration\r\n// (replaces any existing entries)\r\nexport function addToWhitelist(url, minutes) {\r\n    getStorage().then((storage) => {\r\n        let whitelistedSites = storage.whitelistedSites;\r\n        let expiry = addMinutes(new Date(), minutes);\r\n        whitelistedSites[url] = expiry.toJSON();\r\n        setStorage({ whitelistedSites: whitelistedSites }).then(() => {\r\n            console.log(`${url} added to whitelisted sites`);\r\n        });\r\n    });\r\n}\r\nexport function logIntentToStorage(intentString, intentDate, url) {\r\n    getStorage().then((storage) => {\r\n        let intentList = storage.intentList;\r\n        // getting oldest date value from intent list map\r\n        let oldest_date = new Date();\r\n        for (const rawDate in intentList) {\r\n            const date = new Date(rawDate);\r\n            if (date < oldest_date) {\r\n                oldest_date = date;\r\n            }\r\n        }\r\n        // deleting oldest intent to keep intent count under limit\r\n        if (Object.keys(intentList).length > storage.numIntentEntries) {\r\n            console.log(`list full, popping ${oldest_date.toJSON()}`);\r\n            delete intentList[oldest_date.toJSON()];\r\n        }\r\n        // adding new intent and date to intent list\r\n        intentList[intentDate.toJSON()] = {\r\n            intent: intentString,\r\n            url: url,\r\n        };\r\n        // saving intentList to chrome storage\r\n        setStorage({ intentList: intentList }).then(() => {\r\n            console.log(`logged intent \"${intentString}\"`);\r\n        });\r\n    });\r\n}\r\n", "import { getStorage } from './storage';\r\nimport { cleanDomain } from './util';\r\n// when popup is loaded, setup event listeners\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    // setup listener for toggle\r\n    const toggleSwitch = document.querySelector('#reflect-toggle');\r\n    toggleSwitch.addEventListener('change', toggleState, false);\r\n    // get current state and set approriately\r\n    getStorage().then((storage) => {\r\n        // set toggle state to storage value\r\n        toggleSwitch.checked = storage.isEnabled;\r\n        setupBlockListener(storage.blockedSites, storage.enableInvertedMode);\r\n    });\r\n});\r\n// function to update background with current toggle state\r\nfunction toggleState(e) {\r\n    const port = chrome.runtime.connect({\r\n        name: 'toggleState',\r\n    });\r\n    port.postMessage({ state: e.target.checked });\r\n    port.disconnect();\r\n}\r\n// return what current text of button should be\r\nfunction getButtonText(url, blockedSites, invertedMode) {\r\n    if (!invertedMode) {\r\n        return blockedSites.includes(url) ? 'unblock page.' : 'block page.';\r\n    }\r\n    else {\r\n        return blockedSites.includes(url) ? 'unallow page.' : 'allow page.';\r\n    }\r\n}\r\n// setup listener for what block button should do\r\nfunction setupBlockListener(blockedSites, invertedMode) {\r\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n        const urls = tabs.map((x) => x.url);\r\n        const domain = cleanDomain(urls);\r\n        document.getElementById('block').innerHTML = getButtonText(domain, blockedSites, invertedMode);\r\n        // not on a page (probably new tab)\r\n        if (domain === '') {\r\n            document.getElementById('curDomain').textContent = 'none.';\r\n            return;\r\n        }\r\n        document.getElementById('curDomain').textContent = domain;\r\n        document.getElementById('block').addEventListener('click', () => {\r\n            const port = chrome.runtime.connect({\r\n                name: 'blockFromPopup',\r\n            });\r\n            // toggle state text and update background script\r\n            const buttonText = document.getElementById('block').innerHTML;\r\n            if (buttonText == 'block page.' || buttonText == 'allow page.') {\r\n                port.postMessage({ unblock: false, siteURL: domain });\r\n                document.getElementById('block').innerHTML = invertedMode ? 'unallow page.' : 'unblock page.';\r\n            }\r\n            else {\r\n                port.postMessage({ unblock: true, siteURL: domain });\r\n                document.getElementById('block').innerHTML = invertedMode ? 'allow page.' : 'block page.';\r\n            }\r\n            // cleanup connection\r\n            port.disconnect();\r\n        });\r\n    });\r\n}\r\n"],
  "mappings": ";;AAIO,uBAAqB;AAExB,QAAI,KAAK,OAAO;AAEZ,aAAO;AAAA;AAIP,wBAAkB,KAAK,GAAG,MAAM;AAEhC,UAAI,aAAa;AACb,eAAO;AAAA;AAIP,eAAO,UAAU,GAAG,QAAQ,QAAQ;AAAA;AAAA;AAAA;;;ACVzC;AACH,WAAO,IAAI,QAAQ,CAAC;AAChB,aAAO,QAAQ,KAAK,IAAI,MAAM;AAC1B,YAAI,OAAO,QAAQ,cAAc;AAC7B,iBAAO,OAAO,QAAQ;AAAA;AAGtB,kBAAQ;AAAA;AAAA;AAAA;AAAA;;;ACbxB,WAAS,iBAAiB,oBAAoB;AAE1C,UAAM,eAAe,SAAS,cAAc;AAC5C,iBAAa,iBAAiB,UAAU,aAAa;AAErD,iBAAa,KAAK;AAEd,mBAAa,UAAU,SAAQ;AAC/B,yBAAmB,SAAQ,cAAc,SAAQ;AAAA;AAAA;AAIzD;AACI,iBAAa,OAAO,QAAQ,QAAQ;AAAA,MAChC,MAAM;AAAA;AAEV,SAAK,YAAY,CAAE,OAAO,EAAE,OAAO;AACnC,SAAK;AAAA;AAGT;AACI,QAAI,CAAC;AACD,aAAO,aAAa,SAAS,OAAO,kBAAkB;AAAA;AAGtD,aAAO,aAAa,SAAS,OAAO,kBAAkB;AAAA;AAAA;AAI9D;AACI,WAAO,KAAK,MAAM,CAAE,QAAQ,MAAM,eAAe,OAAQ;AACrD,mBAAa,KAAK,IAAI,OAAO,EAAE;AAC/B,qBAAe,YAAY;AAC3B,eAAS,eAAe,SAAS,YAAY,cAAc,QAAQ,cAAc;AAEjF,UAAI,WAAW;AACX,iBAAS,eAAe,aAAa,cAAc;AACnD;AAAA;AAEJ,eAAS,eAAe,aAAa,cAAc;AACnD,eAAS,eAAe,SAAS,iBAAiB,SAAS;AACvD,qBAAa,OAAO,QAAQ,QAAQ;AAAA,UAChC,MAAM;AAAA;AAGV,2BAAmB,SAAS,eAAe,SAAS;AACpD,YAAI,cAAc,iBAAiB,cAAc;AAC7C,eAAK,YAAY,CAAE,SAAS,OAAO,SAAS;AAC5C,mBAAS,eAAe,SAAS,YAAY,eAAe,kBAAkB;AAAA;AAG9E,eAAK,YAAY,CAAE,SAAS,MAAM,SAAS;AAC3C,mBAAS,eAAe,SAAS,YAAY,eAAe,gBAAgB;AAAA;AAGhF,aAAK;AAAA;AAAA;AAAA;",
  "names": []
}
