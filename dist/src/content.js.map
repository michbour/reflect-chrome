{
  "version": 3,
  "sources": ["../../build/blob_animation.js", "../../build/util.js", "../../build/storage.js", "../../build/onboarding_options.js", "../../build/content.js"],
  "sourcesContent": ["// blob_animation.ts is a module which provides a class to easily instantiate the animations on the block page\r\nclass BlobElement {\r\n    constructor(x, y, r, is3D) {\r\n        this.x = this.originalX = x;\r\n        this.y = this.originalY = y;\r\n        this.r = r || 10;\r\n        this.element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        this.fill = is3D ? 'url(#_r_gradient)' : '#A6B1CE';\r\n        // set styling\r\n        this.element.setAttribute('r', this.r.toString());\r\n        this.element.setAttribute('style', `fill: ${this.fill};`);\r\n    }\r\n    // update element\r\n    update(mouseX, mouseY, repulsion, attraction) {\r\n        const dx = this.x - mouseX;\r\n        const dy = this.y - mouseY;\r\n        const angle = Math.atan2(dy, dx);\r\n        const dist = repulsion / Math.sqrt(dx * dx + dy * dy);\r\n        this.x += Math.cos(angle) * dist;\r\n        this.y += Math.sin(angle) * dist;\r\n        this.x += (this.originalX - this.x) * attraction;\r\n        this.y += (this.originalY - this.y) * attraction;\r\n        this.element.setAttribute('cx', this.x.toString());\r\n        this.element.setAttribute('cy', this.y.toString());\r\n    }\r\n}\r\nexport default class BlobAnimation {\r\n    constructor(is3D) {\r\n        this.config = {\r\n            blur: 8,\r\n            alphaMult: 30,\r\n            alphaAdd: -10,\r\n            numSeeds: 6,\r\n            childrenPerSeed: 4,\r\n            childrenDistanceRange: 125,\r\n            circleMinRadius: 15,\r\n            circleMaxRadius: 75,\r\n            attraction: 0.1,\r\n            repulsion: 1000,\r\n        };\r\n        this.animate = () => {\r\n            requestAnimationFrame(this.animate);\r\n            this.elements.forEach((e) => {\r\n                e.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n            });\r\n        };\r\n        this.is3D = is3D;\r\n        // grab dom elements\r\n        this.svg = document.getElementById('svg');\r\n        this.colorMatrixF = document.getElementById('colorMatrixF');\r\n        // bind event listeners\r\n        const body = document.getElementById('reflect-main');\r\n        window.addEventListener('resize', this.onResize, false);\r\n        body.addEventListener('mousemove', (e) => {\r\n            this.mouseX = e.clientX;\r\n            this.mouseY = e.clientY;\r\n        }, false);\r\n        body.addEventListener('mouseleave', this.resetMouse, false);\r\n        // create initial svg g elements\r\n        this.onResize();\r\n        this.resetMouse();\r\n        this.initElements();\r\n        this.colorMatrixF.setAttribute('values', `1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 ${this.config.alphaMult} ${this.config.alphaAdd}`);\r\n    }\r\n    random(min, max) {\r\n        return min + Math.random() * (max - min);\r\n    }\r\n    randomRange(targ, range) {\r\n        return targ + (Math.random() * 2 - 1) * range;\r\n    }\r\n    initElements() {\r\n        // create group div with namespace\r\n        this.elements = [];\r\n        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this.svg.appendChild(group);\r\n        // create seeds\r\n        for (let i = 0; i < this.config.numSeeds; i++) {\r\n            const e = new BlobElement(this.random(this.width * 0.4, this.width), this.randomRange(this.centerY, this.height * 0.4), this.random(this.config.circleMinRadius, this.config.circleMaxRadius), this.is3D);\r\n            e.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n            group.appendChild(e.element);\r\n            this.elements.push(e);\r\n        }\r\n        // add children to seeds\r\n        this.elements.forEach((e) => {\r\n            for (let j = 0; j < this.config.childrenPerSeed; j++) {\r\n                const child = new BlobElement(this.randomRange(e.x, this.config.childrenDistanceRange), this.randomRange(e.y, this.config.childrenDistanceRange), this.random(this.config.circleMinRadius, this.config.circleMaxRadius), this.is3D);\r\n                child.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n                group.appendChild(child.element);\r\n                this.elements.push(child);\r\n            }\r\n        });\r\n    }\r\n    // set mouse cords back to bottom centre screen\r\n    resetMouse() {\r\n        this.mouseX = this.centerX;\r\n        this.mouseY = 5 * this.centerY;\r\n    }\r\n    // recompute width, height, and centre\r\n    onResize() {\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        this.centerX = this.width / 2;\r\n        this.centerY = this.height / 2;\r\n    }\r\n}\r\n", "// util.ts provides utility functions that can be reused in other modules\r\nexport function addMinutes(date, minutes) {\r\n    return new Date(date.getTime() + minutes * 60000);\r\n}\r\nexport function cleanDomain(urls) {\r\n    // check to see if urls exist\r\n    if (urls[0] === undefined) {\r\n        // return empty if not\r\n        return '';\r\n    }\r\n    else {\r\n        // regex match for url\r\n        const activeURL = urls[0].match(/^[\\w]+:\\/{2}([\\w\\.:-]+)/);\r\n        // no matching sites, return empty\r\n        if (activeURL == null) {\r\n            return '';\r\n        }\r\n        else {\r\n            // strip www.\r\n            return activeURL[1].replace('www.', '');\r\n        }\r\n    }\r\n}\r\nexport function insertAfter(newNode, existingNode) {\r\n    existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);\r\n}\r\nexport function createDivFromHTML(htmlString) {\r\n    const newDiv = document.createElement('div');\r\n    newDiv.insertAdjacentHTML('beforeend', htmlString);\r\n    return newDiv;\r\n}\r\nexport function getElementFromForm(id) {\r\n    return document.getElementById(id);\r\n}\r\n", "// storage.ts provides a thin wrapper around the chrome storage api to make it easier to read/write from it\r\n// you can also find helper functions that read/write to chrome storage\r\nimport { addMinutes } from './util';\r\n// helper function to retrive chrome storage object\r\n// usage:\r\n//\r\n// getStorage(null).then(storage => {\r\n//     ...\r\n// })\r\nexport function getStorage() {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.get(null, (storage) => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve(storage);\r\n            }\r\n        });\r\n    });\r\n}\r\n// helper function to set fields in chrome storage\r\n// usage:\r\n//\r\n// getStorage({enableBlobs: false}).then(storage => {\r\n//     ...\r\n// })\r\nexport function setStorage(key) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.set(key, () => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n// Add a single url to blocklist (does nothing if url is already in list)\r\nexport function addToBlocked(url, callback) {\r\n    getStorage().then((storage) => {\r\n        if (!storage.blockedSites.includes(url)) {\r\n            storage.blockedSites.push(url);\r\n            setStorage({ blockedSites: storage.blockedSites }).then(() => {\r\n                console.log(`${url} added to blocked sites`);\r\n                callback ? callback() : () => { };\r\n            });\r\n        }\r\n    });\r\n}\r\n// Remove single url from blocklist (does nothing if url is not in list)\r\nexport function removeFromBlocked(url) {\r\n    getStorage().then((storage) => {\r\n        let blockedSites = storage.blockedSites;\r\n        blockedSites = blockedSites.filter((e) => e !== url);\r\n        setStorage({ blockedSites: blockedSites }).then(() => {\r\n            console.log(`removed ${url} from blocked sites`);\r\n        });\r\n    });\r\n}\r\n// Add a single url to whitelist with associated whitelist duration\r\n// (replaces any existing entries)\r\nexport function addToWhitelist(url, minutes) {\r\n    getStorage().then((storage) => {\r\n        let whitelistedSites = storage.whitelistedSites;\r\n        let expiry = addMinutes(new Date(), minutes);\r\n        whitelistedSites[url] = expiry.toJSON();\r\n        setStorage({ whitelistedSites: whitelistedSites }).then(() => {\r\n            console.log(`${url} added to whitelisted sites`);\r\n        });\r\n    });\r\n}\r\nexport function logIntentToStorage(intentString, intentDate, url) {\r\n    getStorage().then((storage) => {\r\n        let intentList = storage.intentList;\r\n        // getting oldest date value from intent list map\r\n        let oldest_date = new Date();\r\n        for (const rawDate in intentList) {\r\n            const date = new Date(rawDate);\r\n            if (date < oldest_date) {\r\n                oldest_date = date;\r\n            }\r\n        }\r\n        // deleting oldest intent to keep intent count under limit\r\n        if (Object.keys(intentList).length > storage.numIntentEntries) {\r\n            console.log(`list full, popping ${oldest_date.toJSON()}`);\r\n            delete intentList[oldest_date.toJSON()];\r\n        }\r\n        // adding new intent and date to intent list\r\n        intentList[intentDate.toJSON()] = {\r\n            intent: intentString,\r\n            url: url,\r\n        };\r\n        // saving intentList to chrome storage\r\n        setStorage({ intentList: intentList }).then(() => {\r\n            console.log(`logged intent \"${intentString}\"`);\r\n        });\r\n    });\r\n}\r\n", "import { getStorage, setStorage } from './storage';\r\nimport { createDivFromHTML, insertAfter, getElementFromForm } from './util';\r\nconst getSettingsHTMLString = () => {\r\n    return `\r\n    <table class=\"options_panel\">\r\n        <tr>\r\n            <td style=\"width:60%\">\r\n                <h3 class=\"setting\">enable blobs.</h3>\r\n                <p class=\"subtext\">whether to render the interactive blobs on the block page.</p>\r\n            </td>\r\n            <td>\r\n                <input class='toggle' id='enableBlobs' type='checkbox'>\r\n                <label class='toggle-button' for='enableBlobs'></label>\r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td>\r\n                <h3 class=\"setting\">enable 3D.</h3>\r\n                <p class=\"subtext\">whether to enable the 3D-like effect on the blobs on the block page.</p>\r\n            </td>\r\n            <td>\r\n                <input class='toggle' id='enable3D' type='checkbox'>\r\n                <label class='toggle-button' for='enable3D'></label>\r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td>\r\n                <h3 class=\"setting\">whitelist time.</h3>\r\n                <p class=\"subtext\">time allowed on a website after successful intent (minutes).</p>\r\n            </td>\r\n            <td>\r\n                <input id=\"whitelistTime\" type=\"number\" min=\"0\">\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <p id=\"statusMessage\">\r\n        <span id=\"statusContent\"></span>\r\n        <span>&nbsp;</span>\r\n    </p>\r\n    `;\r\n};\r\nconst saveSettings = () => {\r\n    const whitelistTime = getElementFromForm('whitelistTime').value;\r\n    const enableBlobs = getElementFromForm('enableBlobs').checked;\r\n    const enable3D = getElementFromForm('enable3D').checked;\r\n    setStorage({\r\n        whitelistTime: whitelistTime,\r\n        enableBlobs: enableBlobs,\r\n        enable3D: enable3D,\r\n    }).then(() => {\r\n        // Update status to let user know options were saved.\r\n        const status = document.getElementById('statusContent');\r\n        status.textContent = 'options saved.';\r\n        setTimeout(() => {\r\n            status.textContent = '';\r\n        }, 1500);\r\n    });\r\n};\r\nexport default () => {\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n        getStorage().then((storage) => {\r\n            var _a, _b;\r\n            getElementFromForm('whitelistTime').value = storage.whitelistTime;\r\n            getElementFromForm('enableBlobs').checked = (_a = storage.enableBlobs, (_a !== null && _a !== void 0 ? _a : true));\r\n            getElementFromForm('enable3D').checked = (_b = storage.enable3D, (_b !== null && _b !== void 0 ? _b : true));\r\n        });\r\n        const optionsDiv = document.getElementById('options');\r\n        // change last button to say it will skip rather than setting settings\r\n        const goToEndButton = document.getElementById('page3button');\r\n        goToEndButton.innerText = 'skip.';\r\n        const newOptionsSection = createDivFromHTML(`\r\n            <div class=\"text-section\">\r\n                <h2>configure.</h2>\r\n                <p>buttons and knobs to customize your reflect experience.</p>\r\n                ${getSettingsHTMLString()}\r\n                <a id=\"saveButton\" class=\"lt-hover white_button shadow nextPage\">save!</a>\r\n            </div>\r\n            `);\r\n        insertAfter(newOptionsSection, optionsDiv);\r\n        document.getElementById('saveButton').addEventListener('click', saveSettings);\r\n    });\r\n};\r\n", "import BlobAnimation from './blob_animation';\r\nimport { getStorage, logIntentToStorage } from './storage';\r\nimport { cleanDomain } from './util';\r\nimport injectOptionsToOnboarding from './onboarding_options';\r\n// some constants\r\nconst REFLECT_INFO = '#576ca8';\r\nconst REFLECT_ERR = '#ff4a47';\r\nconst REFLECT_ONBOARDING_URL = 'https://getreflect.app/onboarding/';\r\nconst DEV_REFLECT_ONBOARDING_URL = 'http://localhost:1313/onboarding/';\r\n// as soon as page loads, check if we need to block it\r\ncheckIfBlocked();\r\n// re-check page everytime this page gets focus again\r\nwindow.addEventListener('focus', checkIfBlocked);\r\n// check to see if the current website needs to be blocked\r\nfunction checkIfBlocked() {\r\n    // if onboarding, inject options to page\r\n    if (window.location.href === REFLECT_ONBOARDING_URL ||\r\n        window.location.href === DEV_REFLECT_ONBOARDING_URL) {\r\n        injectOptionsToOnboarding();\r\n        return;\r\n    }\r\n    // if already on reflect page, don't need to re-block\r\n    if (!!document.getElementById('reflect-main')) {\r\n        return;\r\n    }\r\n    getStorage().then((storage) => {\r\n        if (!storage.isEnabled) {\r\n            return;\r\n        }\r\n        const strippedURL = getStrippedUrl();\r\n        if (storage.enableInvertedMode) {\r\n            let inWhitelistedSites = storage.blockedSites.some((site) => strippedURL.includes(site));\r\n            if (!inWhitelistedSites) {\r\n                iterWhitelist();\r\n            }\r\n        }\r\n        else {\r\n            // match current url against stored blocklist\r\n            storage.blockedSites.forEach((site) => {\r\n                if (strippedURL.includes(site) && !isWhitelistedWrapper()) {\r\n                    // found a match, check if currently on whitelist\r\n                    iterWhitelist();\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n// display a message under intent entry field\r\nfunction displayStatus(message, duration = 3000, colour = REFLECT_INFO) {\r\n    $('#statusContent').css('color', colour);\r\n    $('#statusContent').text(message);\r\n    $('#statusContent').show().delay(duration).fadeOut();\r\n}\r\n// check to see if domain is whitelisted\r\nfunction isWhitelistedWrapper() {\r\n    const WHITELISTED_WRAPPERS = ['facebook.com/flx', 'l.facebook.com'];\r\n    return WHITELISTED_WRAPPERS.some((wrapper) => window.location.href.includes(wrapper));\r\n}\r\n// thin wrapper around util.ts/cleanDomain\r\nfunction getStrippedUrl() {\r\n    return cleanDomain([window.location.href]);\r\n}\r\nfunction iterWhitelist() {\r\n    // iterate whitelisted sites\r\n    getStorage().then((storage) => {\r\n        const strippedURL = getStrippedUrl();\r\n        if (strippedURL === '') {\r\n            return;\r\n        }\r\n        // get dictionary of whitelisted sites\r\n        const whitelist = storage.whitelistedSites;\r\n        // is current url whitelisted?\r\n        if (!whitelist.hasOwnProperty(strippedURL)) {\r\n            loadBlockPage(strippedURL);\r\n            return;\r\n        }\r\n        // check if whitelist period is expired\r\n        const parsedDate = new Date(whitelist[strippedURL]);\r\n        const currentDate = new Date();\r\n        const expired = currentDate >= parsedDate;\r\n        if (expired) {\r\n            loadBlockPage(strippedURL);\r\n            return;\r\n        }\r\n        const timeDifference = parsedDate.getTime() - currentDate.getTime();\r\n        // set timer to re-block page after whitelist period expires\r\n        setTimeout(() => {\r\n            loadBlockPage(strippedURL);\r\n        }, timeDifference);\r\n    });\r\n}\r\n// replace current page with reflect block page\r\nfunction loadBlockPage(strippedURL) {\r\n    const prompt_page_url = chrome.runtime.getURL('res/pages/prompt.html');\r\n    const options_page_url = chrome.runtime.getURL('res/pages/options.html');\r\n    getStorage().then((storage) => {\r\n        // get prompt page content\r\n        $.get(prompt_page_url, (page) => {\r\n            var _a, _b;\r\n            // stop current page and replace with our blocker page\r\n            window.stop();\r\n            $('html').html(page);\r\n            addFormListener(strippedURL);\r\n            $('#linkToOptions').attr('href', options_page_url);\r\n            if (_a = storage.enableBlobs, (_a !== null && _a !== void 0 ? _a : true)) {\r\n                const anim = new BlobAnimation((_b = storage.enable3D, (_b !== null && _b !== void 0 ? _b : true)));\r\n                anim.animate();\r\n            }\r\n            // modify custom message based on user input\r\n            const welcome = document.getElementById('customMessageContent');\r\n            welcome.textContent = storage.customMessage || 'hey! what are you here for?';\r\n        });\r\n    });\r\n}\r\nfunction addFormListener(strippedURL) {\r\n    var _a;\r\n    const form = document.forms.namedItem('inputForm');\r\n    // add listener for form submit\r\n    (_a = form) === null || _a === void 0 ? void 0 : _a.addEventListener('submit', (event) => {\r\n        // prevent default submit\r\n        event.preventDefault();\r\n        // extract entry\r\n        const intentForm = event.target;\r\n        const intent = new FormData(intentForm).get('intent');\r\n        const intentString = intent.toString();\r\n        const intentDate = new Date();\r\n        callBackgroundWithIntent(intentString);\r\n        logIntentToStorage(intentString, intentDate, strippedURL);\r\n    });\r\n}\r\nfunction callBackgroundWithIntent(intent) {\r\n    // open connection to runtime (background.ts)\r\n    const port = chrome.runtime.connect({\r\n        name: 'intentStatus',\r\n    });\r\n    // send message then wait for response\r\n    port.postMessage({ intent: intent, url: window.location.href });\r\n    port.onMessage.addListener((msg) => {\r\n        switch (msg.status) {\r\n            case 'ok':\r\n                // show success message\r\n                getStorage().then((storage) => {\r\n                    const WHITELIST_PERIOD = storage.whitelistTime;\r\n                    displayStatus(`got it! ${WHITELIST_PERIOD} minutes starting now.`, 3000, REFLECT_INFO);\r\n                    location.reload();\r\n                });\r\n                break;\r\n            case 'too_short':\r\n                invalidIntent('your response is a little short. be more specific!');\r\n                break;\r\n            case 'invalid':\r\n                invalidIntent(\"that doesn't seem to be productive. try being more specific.\");\r\n                break;\r\n        }\r\n        // close connection\r\n        port.disconnect();\r\n    });\r\n}\r\nfunction invalidIntent(msg) {\r\n    $('#inputFields').effect('shake', { times: 3, distance: 5 });\r\n    displayStatus(msg, 3000, REFLECT_ERR);\r\n    $('#textbox').val('');\r\n}\r\n"],
  "mappings": ";;AAAA,MAAA;AAAA,IAEI;AACI,WAAK,IAAI,KAAK,YAAY;AAC1B,WAAK,IAAI,KAAK,YAAY;AAC1B,WAAK,IAAI,KAAK;AACd,WAAK,UAAU,SAAS,gBAAgB,8BAA8B;AACtE,WAAK,OAAO,OAAO,sBAAsB;AAEzC,WAAK,QAAQ,aAAa,KAAK,KAAK,EAAE;AACtC,WAAK,QAAQ,aAAa,SAAS,SAAS,KAAK;AAAA;AAAA,IAGrD;AACI,iBAAW,KAAK,IAAI;AACpB,iBAAW,KAAK,IAAI;AACpB,oBAAc,KAAK,MAAM,IAAI;AAC7B,mBAAa,YAAY,KAAK,KAAK,KAAK,KAAK,KAAK;AAClD,WAAK,KAAK,KAAK,IAAI,SAAS;AAC5B,WAAK,KAAK,KAAK,IAAI,SAAS;AAC5B,WAAK,KAAM,MAAK,YAAY,KAAK,KAAK;AACtC,WAAK,KAAM,MAAK,YAAY,KAAK,KAAK;AACtC,WAAK,QAAQ,aAAa,MAAM,KAAK,EAAE;AACvC,WAAK,QAAQ,aAAa,MAAM,KAAK,EAAE;AAAA;AAAA;AAvB/C;AAAA,IA2BI;AACI,WAAK,SAAS;AAAA,QACV,MAAM;AAAA,QACN,WAAW;AAAA,QACX,UAAU;AAAA,QACV,UAAU;AAAA,QACV,iBAAiB;AAAA,QACjB,uBAAuB;AAAA,QACvB,iBAAiB;AAAA,QACjB,iBAAiB;AAAA,QACjB,YAAY;AAAA,QACZ,WAAW;AAAA;AAEf,WAAK,UAAU;AACX,8BAAsB,KAAK;AAC3B,aAAK,SAAS,QAAQ;AAClB,YAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ,KAAK,OAAO,WAAW,KAAK,OAAO;AAAA;AAAA;AAG9E,WAAK,OAAO;AAEZ,WAAK,MAAM,SAAS,eAAe;AACnC,WAAK,eAAe,SAAS,eAAe;AAE5C,mBAAa,SAAS,eAAe;AACrC,aAAO,iBAAiB,UAAU,KAAK,UAAU;AACjD,WAAK,iBAAiB,aAAa;AAC/B,aAAK,SAAS,EAAE;AAChB,aAAK,SAAS,EAAE;AAAA,SACjB;AACH,WAAK,iBAAiB,cAAc,KAAK,YAAY;AAErD,WAAK;AACL,WAAK;AACL,WAAK;AACL,WAAK,aAAa,aAAa,UAAU,uCAAuC,KAAK,OAAO,aAAa,KAAK,OAAO;AAAA;AAAA,IAEzH;AACI,aAAO,MAAM,KAAK,WAAY,OAAM;AAAA;AAAA,IAExC;AACI,aAAO,OAAQ,MAAK,WAAW,IAAI,KAAK;AAAA;AAAA,IAE5C;AAEI,WAAK,WAAW;AAChB,oBAAc,SAAS,gBAAgB,8BAA8B;AACrE,WAAK,IAAI,YAAY;AAErB,mBAAa,GAAG,IAAI,KAAK,OAAO,UAAU;AACtC,kBAAU,IAAI,YAAY,KAAK,OAAO,KAAK,QAAQ,KAAK,KAAK,QAAQ,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,MAAM,KAAK,OAAO,KAAK,OAAO,iBAAiB,KAAK,OAAO,kBAAkB,KAAK;AACpM,UAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ,KAAK,OAAO,WAAW,KAAK,OAAO;AACtE,cAAM,YAAY,EAAE;AACpB,aAAK,SAAS,KAAK;AAAA;AAGvB,WAAK,SAAS,QAAQ;AAClB,qBAAa,GAAG,IAAI,KAAK,OAAO,iBAAiB;AAC7C,wBAAc,IAAI,YAAY,KAAK,YAAY,EAAE,GAAG,KAAK,OAAO,wBAAwB,KAAK,YAAY,EAAE,GAAG,KAAK,OAAO,wBAAwB,KAAK,OAAO,KAAK,OAAO,iBAAiB,KAAK,OAAO,kBAAkB,KAAK;AAC9N,gBAAM,OAAO,KAAK,QAAQ,KAAK,QAAQ,KAAK,OAAO,WAAW,KAAK,OAAO;AAC1E,gBAAM,YAAY,MAAM;AACxB,eAAK,SAAS,KAAK;AAAA;AAAA;AAAA;AAAA,IAK/B;AACI,WAAK,SAAS,KAAK;AACnB,WAAK,SAAS,IAAI,KAAK;AAAA;AAAA,IAG3B;AACI,WAAK,QAAQ,OAAO;AACpB,WAAK,SAAS,OAAO;AACrB,WAAK,UAAU,KAAK,QAAQ;AAC5B,WAAK,UAAU,KAAK,SAAS;AAAA;AAAA;AAtGrC;;;ACIO,uBAAqB;AAExB,QAAI,KAAK,OAAO;AAEZ,aAAO;AAAA;AAIP,wBAAkB,KAAK,GAAG,MAAM;AAEhC,UAAI,aAAa;AACb,eAAO;AAAA;AAIP,eAAO,UAAU,GAAG,QAAQ,QAAQ;AAAA;AAAA;AAAA;AAIzC;AACH,iBAAa,WAAW,aAAa,SAAS,aAAa;AAAA;AAExD;AACH,mBAAe,SAAS,cAAc;AACtC,WAAO,mBAAmB,aAAa;AACvC,WAAO;AAAA;AAEJ;AACH,WAAO,SAAS,eAAe;AAAA;;;ACvB5B;AACH,WAAO,IAAI,QAAQ,CAAC;AAChB,aAAO,QAAQ,KAAK,IAAI,MAAM;AAC1B,YAAI,OAAO,QAAQ,cAAc;AAC7B,iBAAO,OAAO,QAAQ;AAAA;AAGtB,kBAAQ;AAAA;AAAA;AAAA;AAAA;AAWjB;AACH,WAAO,IAAI,QAAQ;AACf,aAAO,QAAQ,KAAK,IAAI,KAAK;AACzB,YAAI,OAAO,QAAQ,cAAc;AAC7B,iBAAO,OAAO,QAAQ;AAAA;AAGtB;AAAA;AAAA;AAAA;AAAA;AAuCT,8BAA4B;AAC/B,iBAAa,KAAK;AACd,uBAAiB,SAAQ;AAEzB,wBAAkB,IAAI;AACtB,4BAAsB;AAClB,qBAAa,IAAI,KAAK;AACtB,YAAI,OAAO;AACP,wBAAc;AAAA;AAAA;AAItB,UAAI,OAAO,KAAK,YAAY,SAAS,SAAQ;AACzC,gBAAQ,IAAI,sBAAsB,YAAY;AAC9C,eAAO,WAAW,YAAY;AAAA;AAGlC,iBAAW,WAAW,YAAY;AAAA,QAC9B,QAAQ;AAAA,QACR;AAAA;AAGJ,iBAAW,CAAE,aAA0B,KAAK;AACxC,gBAAQ,IAAI,kBAAkB;AAAA;AAAA;AAAA;;;AC9F1C,MAAM,wBAAwB;AAC1B,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCX,qBAAqB;AACjB,0BAAsB,mBAAmB,iBAAiB;AAC1D,wBAAoB,mBAAmB,eAAe;AACtD,qBAAiB,mBAAmB,YAAY;AAChD,eAAW;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,OACD,KAAK;AAEJ,qBAAe,SAAS,eAAe;AACvC,aAAO,cAAc;AACrB,iBAAW;AACP,eAAO,cAAc;AAAA,SACtB;AAAA;AAAA;AAGX,mCAAe;AACX,aAAS,iBAAiB,oBAAoB;AAC1C,mBAAa,KAAK;AACd;AACA,2BAAmB,iBAAiB,QAAQ,SAAQ;AACpD,2BAAmB,eAAe,UAAW,MAAK,SAAQ,aAAc,OAAO,QAAQ,OAAO,SAAS,KAAK;AAC5G,2BAAmB,YAAY,UAAW,MAAK,SAAQ,UAAW,OAAO,QAAQ,OAAO,SAAS,KAAK;AAAA;AAE1G,yBAAmB,SAAS,eAAe;AAE3C,4BAAsB,SAAS,eAAe;AAC9C,oBAAc,YAAY;AAC1B,gCAA0B,kBAAkB;AAAA;AAAA;AAAA;AAAA,kBAIlC;AAAA;AAAA;AAAA;AAIV,kBAAY,mBAAmB;AAC/B,eAAS,eAAe,cAAc,iBAAiB,SAAS;AAAA;AAAA;;;AC1ExE,MAAM,eAAe;AACrB,oBAAoB;AACpB,+BAA+B;AAC/B,mCAAmC;AAEnC;AAEA,SAAO,iBAAiB,SAAS;AAEjC;AAEI,QAAI,OAAO,SAAS,SAAS,0BACzB,OAAO,SAAS,SAAS;AACzB;AACA;AAAA;AAGJ,QAAI,CAAC,CAAC,SAAS,eAAe;AAC1B;AAAA;AAEJ,iBAAa,KAAK;AACd,UAAI,CAAC,SAAQ;AACT;AAAA;AAEJ,0BAAoB;AACpB,UAAI,SAAQ;AACR,iCAAyB,SAAQ,aAAa,KAAK,UAAU,YAAY,SAAS;AAClF,YAAI,CAAC;AACD;AAAA;AAAA;AAKJ,iBAAQ,aAAa,QAAQ;AACzB,cAAI,YAAY,SAAS,SAAS,CAAC;AAE/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAOpB,6CAA2C,cAAe;AACtD,MAAE,kBAAkB,IAAI,SAAS;AACjC,MAAE,kBAAkB,KAAK;AACzB,MAAE,kBAAkB,OAAO,MAAM,UAAU;AAAA;AAG/C;AACI,iCAA6B,CAAC,oBAAoB;AAClD,WAAO,qBAAqB,KAAK,aAAa,OAAO,SAAS,KAAK,SAAS;AAAA;AAGhF;AACI,WAAO,YAAY,CAAC,OAAO,SAAS;AAAA;AAExC;AAEI,iBAAa,KAAK;AACd,0BAAoB;AACpB,UAAI,gBAAgB;AAChB;AAAA;AAGJ,wBAAkB,SAAQ;AAE1B,UAAI,CAAC,UAAU,eAAe;AAC1B,sBAAc;AACd;AAAA;AAGJ,yBAAmB,IAAI,KAAK,UAAU;AACtC,0BAAoB,IAAI;AACxB,sBAAgB,eAAe;AAC/B,UAAI;AACA,sBAAc;AACd;AAAA;AAEJ,6BAAuB,WAAW,YAAY,YAAY;AAE1D,iBAAW;AACP,sBAAc;AAAA,SACf;AAAA;AAAA;AAIX;AACI,4BAAwB,OAAO,QAAQ,OAAO;AAC9C,6BAAyB,OAAO,QAAQ,OAAO;AAC/C,iBAAa,KAAK;AAEd,QAAE,IAAI,iBAAiB;AACnB;AAEA,eAAO;AACP,UAAE,QAAQ,KAAK;AACf,wBAAgB;AAChB,UAAE,kBAAkB,KAAK,QAAQ;AACjC,YAAI,KAAK,SAAQ,aAAc,OAAO,QAAQ,OAAO,SAAS,KAAK;AAC/D,uBAAa,IAAI,uBAAe,MAAK,SAAQ,UAAW,OAAO,QAAQ,OAAO,SAAS,KAAK;AAC5F,eAAK;AAAA;AAGT,wBAAgB,SAAS,eAAe;AACxC,gBAAQ,cAAc,SAAQ,iBAAiB;AAAA;AAAA;AAAA;AAI3D;AACI;AACA,iBAAa,SAAS,MAAM,UAAU;AAEtC,IAAC,MAAK,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,iBAAiB,UAAU;AAE3E,YAAM;AAEN,yBAAmB,MAAM;AACzB,qBAAe,IAAI,SAAS,YAAY,IAAI;AAC5C,2BAAqB,OAAO;AAC5B,yBAAmB,IAAI;AACvB,+BAAyB;AACzB,yBAAmB,cAAc,YAAY;AAAA;AAAA;AAGrD;AAEI,iBAAa,OAAO,QAAQ,QAAQ;AAAA,MAChC,MAAM;AAAA;AAGV,SAAK,YAAY,CAAE,QAAgB,KAAK,OAAO,SAAS;AACxD,SAAK,UAAU,YAAY;AACvB,cAAQ,IAAI;AAAA,aACH;AAED,uBAAa,KAAK;AACd,qCAAyB,SAAQ;AACjC,0BAAc,WAAW,0CAA0C,KAAM;AACzE,qBAAS;AAAA;AAEb;AAAA,aACC;AACD,wBAAc;AACd;AAAA,aACC;AACD,wBAAc;AACd;AAAA;AAGR,WAAK;AAAA;AAAA;AAGb;AACI,MAAE,gBAAgB,OAAO,SAAS,CAAE,OAAO,GAAG,UAAU;AACxD,kBAAc,KAAK,KAAM;AACzB,MAAE,YAAY,IAAI;AAAA;",
  "names": []
}
